<!doctype html>

<html>
  <head>
    <style>
      body { margin-right: 25%; margin-left: 25%; margin-top: 3%; margin-bottom: 15%; }
    </style>
  </head>
  <body>

    <h1>
      Well-Known Binary in the Browser
    </h1>
<p>
TL;DR:
</p><p>
instead of this: 
<pre>st_asgeojson</pre>
</p><p>

you might be able to do this: 
<pre>st_asbinary</pre>
</p><p>

It occurred to me a few days ago after seeing VECNIK the following thought
process: "holy shit, those are just PostGIS queries." And then I remembered something
about some in-browser music stuff and typed arrays and thought: 
"It can't be harder than remembering which letters to capitalize in the GeoJSON spec."
</p><p>

And the thing is: it's really easy, it's really really fast, it is completely already 
integrated into PostGIS and even MySQL, it is an open standard, 
it's a great excuse to think about bytes, and nothing important changes except for the 
annoying things. (Like the word "coordinates" or "we should be trimming these 
long floating point numbers.") And the underlying geometries are identical to the
point that the client rendering stuff shouldn't even change much.
</p><p>

In some of these cases where you have large st_asgeojson queries where a lot of data is
destined for pixelification, maybe try some stuff with st_asbinary, 
or send me a link or something (<a href="http://twitter.com/brian_mount">@brian_mount</a> or 
<a href="http://github.com/bvmou/canvasback">bvmou on github</a>, repo 'canvasback' most directly
relevant.) There is a working server implementation in canvasback of this behavior 
that talks to postgis.
</p><p>

Caveats: I'm totally cheating! But even within the cheat is a lot of good news. The way js
typed arrays work is not quite like casting in C: you have an array of bytes, then you declare 
a typed view and have to access the view in multiples of its type. So take a WKB linestring, it
would look like: [endianness (1 byte), type uint32 (4 bytes), number of points uint32 (4 bytes),
x1 double (8 bytes), y1 double (8 bytes), x2 ..., y2... ]. You can't really do `type = (int*)&thing+1`.
In Webkit and Firefox Nightly+Aurora there is an ArrayBuffer slice method that will work for these
cases but for the moment I am just padding the beginning of the array with 7 garbage bytes and
using a single divisible-by-8 array to access everything. But the awesome thing then is that you could
use these 7 bytes for whatever -- for example a hex id number, or say a CartoDB id, and then pull down 
geojson for labels or an
overlay based on it. I'd love to focus on OSM, so you could even just prepend everything with a few bytes
and have id's and projections in the mix all the time.
</p><p>
I am completely un-bore-able on any of these subjects, if you'd like to get in touch about any
of the above, or stuff left out, email is bvmount at the google mails. 
Another example of this concept <a href="http://h.sfgeo.org/wkbjs/_design/wkbjs/wellknownarray.html">here</a>.
</p><p>

</body>

</html>

